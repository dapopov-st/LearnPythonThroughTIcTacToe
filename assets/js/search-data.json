{
  
    
        "post0": {
            "title": "Guide to Python Through Tic-Tac-Toe",
            "content": "This is a brief guide to Python for users with a knowledge of another language and familiarity with recursion (for example, AP CSA students towards the end of the academic year). It uses minimax, a recursive algorithm which is well explained between 11:19 and 20:57 in CS50 Minimax. If you&#39;re unfamiliar with minimax, it is highly recommended that you watch that part of the video first. The first part of the guide will focus on non-OOP concepts, and I&#39;ll introduce some basic OOP Python basics along with the OOP version of the game in the second part. The OOP version is, in my opinion, cleaner and easier to write since the key aspects of the game&#39;s state can be shared among the methods of the class (ie, we don&#39;t have to think as hard about which functions need which arguments), but I will present it separately in order to make the exposition more gradual. . PART 1: NON-OOP BASICS . First, here&#39;s my non-OOP version of the code for the game of Tic-Tac-Toe. The OOP version is presented later in this document . . The non-OOP code for the game is below . &quot;&quot;&quot;This program lets a person place the first piece on a tic-tac-toe board. The computer uses the minimax algorithm to ensure that the person never wins (a tie is possible). The game is played in the console and numbers for available position are displayed for the person playing. This feature requires the use of two auxiliary functions. In addition, the best possible score and the best move are calculated in a single run of the minimax algorithm.&quot;&quot;&quot; import time # will use this to introduce a pause between the person&#39;s and computer&#39;s choice person_choices = [] computer_choices = [] gameboard = [[&#39;1&#39;, &#39;|&#39;, &#39;2&#39;, &#39;|&#39;, &#39;3&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;4&#39;, &#39;|&#39;, &#39;5&#39;, &#39;|&#39;, &#39;6&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;7&#39;, &#39;|&#39;, &#39;8&#39;, &#39;|&#39;, &#39;9&#39;]] def main(person_choices, computer_choices, gameboard) -&gt; None: user = &quot;person&quot; game_over = False depth = 0 # no moves yet, will track how many moves forward that the computer will evaluate the board print(&quot;Game board: &quot;) print_gameboard(gameboard) while not game_over: # Score starts with 0, so not score is true, once 10 or -10, not score will be false if user == &quot;person&quot;: is_max = True make_move(gameboard, &quot;person&quot;, depth, is_max) print_gameboard(gameboard) _, winner, game_over = check_winner( person_choices, computer_choices) if winner != &quot;Tie&quot; and winner != &quot;&quot;: print(winner) elif game_over: print(&quot;Tie&quot;) time.sleep(.5) user = &quot;computer&quot; elif user == &quot;computer&quot;: is_max = False make_move(gameboard, &quot;computer&quot;, depth, is_max) print(&quot;Computer&#39;s move: &quot;) print_gameboard(gameboard) _, winner, game_over = check_winner( person_choices, computer_choices) if winner != &quot;Tie&quot; and winner != &quot;&quot;: print(winner) elif game_over: print(&quot;Tie&quot;) user = &quot;person&quot; def print_gameboard(board) -&gt; None: &quot;&quot;&quot;Prints the board&quot;&quot;&quot; for i in range(0, len(board)): for j in range(0, len(board)): print(board[i][j], end=&quot; &quot;) print() def make_move(board, user: str, depth: int, is_max: bool) -&gt; None: &quot;&quot;&quot;make_move function takes in the board, the user, depth, and is_max. is_max is True if it&#39;s the person&#39;s term, False otherwise. This function requires input from the user and definitively places the piece, hence it&#39;s not used in minimax&quot;&quot;&quot; while True: try: if user == &quot;person&quot;: position = int(input(&quot;Please enter your placement 1 - 9: &quot;)) while (position in person_choices) or (position in computer_choices): print( &quot;You either did not enter an integer between 1 and 9 or the position is taken&quot;) position = int( input(&quot;Please enter your placement 1 - 9: &quot;)) elif user == &quot;computer&quot;: _, *bestMove = minimax(board, depth, is_max, person_choices, computer_choices) position = convert_to_pos(*bestMove) except ValueError as er: print(&quot;You must enter an integer&quot;, er) else: place_position(position, board, user) break def place_position(position, board, user) -&gt; None: &quot;&quot;&quot;Places the user&#39;s piece at the specified position on the board&quot;&quot;&quot; symbol = &quot;X&quot; if user == &quot;person&quot; else &quot;O&quot; # fills out the first row of of the board position_helper(1, 4, 0, board, position, symbol) # fills out the second row of of the board position_helper(4, 7, 2, board, position, symbol) # fills out the third row of of the board position_helper(7, 10, 4, board, position, symbol) def position_helper(a, b, c, board, position, symbol) -&gt; None: &quot;&quot;&quot;Used in the place_position function to avoid repetition&quot;&quot;&quot; for i in range(a, b): if position == i: board[c][2 * (i - a)] = symbol if symbol == &#39;X&#39;: person_choices.append(position) elif symbol == &#39;O&#39;: computer_choices.append(position) def convert_to_pos(i, j) -&gt; int: &quot;&quot;&quot;Converts board coordinates to a position 1-9 on the board&quot;&quot;&quot; positionsDict = {(0, 0): 1, (0, 2): 2, (0, 4): 3, (2, 0): 4, (2, 2): 5, (2, 4): 6, (4, 0): 7, (4, 2): 8, (4, 4): 9} return positionsDict[(i, j)] def convert_pos_to_board(pos) -&gt; tuple: &quot;&quot;&quot;Converts a position 1-9 on the board to board coordinates &quot;&quot;&quot; boardDict = {1: (0, 0), 2: (0, 2), 3: (0, 4), 4: (2, 0), 5: ( 2, 2), 6: (2, 4), 7: (4, 0), 8: (4, 2), 9: (4, 4)} return boardDict[pos] def minimax(board, depth, is_max, person_choices, computer_choices) -&gt; &quot;tuple (&#39;best_score&#39;, &#39;best_move_row&#39;, &#39;best_move_col&#39;)&quot;: &quot;&quot;&quot;The minimax algorithm evaluates all future positions, assuming that the opponent plays optimally in the future. It returns the score, row, and column of the best move&quot;&quot;&quot; user = &quot;person&quot; if is_max else &quot;computer&quot; score, *_ = check_winner(person_choices, computer_choices) if score == 10 or score == -10: return score, 1, 1 # come back to this and see if can fix if len(person_choices) + len(computer_choices) == 9: return 5, 0, 0 if is_max: # person&#39;s turn best_score, best_move_row, best_move_col = -1000, 1, 1 for i in range(3): for j in range(3): if board[2 * i][2 * j] != &quot;X&quot; and board[2 * i][2 * j] != &quot;O&quot;: position = convert_to_pos(2 * i, 2 * j) place_position(position, board, user) score, *_ = minimax( board, depth + 1, False, person_choices, computer_choices) person_choices.pop() m, n = convert_pos_to_board(position) # undoing the move and rewriting the num on board board[m][n] = position if score &gt; best_score: best_score, best_move_row, best_move_col = score, m, n else: # repetitive logic, but easier to see the algorithm at a glance this way best_score, best_move_row, best_move_col = 1000, -1, -1 for i in range(3): for j in range(3): if board[2 * i][2 * j] != &quot;X&quot; and board[2 * i][2 * j] != &quot;O&quot;: position = convert_to_pos(2 * i, 2 * j) place_position(position, board, user) score, *_ = minimax( board, depth + 1, True, person_choices, computer_choices) computer_choices.pop() m, n = convert_pos_to_board(position) board[m][n] = position if score &lt; best_score: best_score, best_move_row, best_move_col = score, m, n return best_score, best_move_row, best_move_col def check_winner(person_choices, computer_choices) -&gt; &quot;tuple (&#39;score&#39;, &#39;result&#39;, &#39;game_over&#39;)&quot;: &quot;&quot;&quot;Given user, person_choices, and computer_choices, checks for the winner. Return the score, winner/tie/&quot;&quot;, and True if the game is over/False if not&quot;&quot;&quot; all_winning = ((1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 4, 7), (2, 5, 8), (3, 6, 9), (1, 5, 9), (3, 5, 7)) # tuple of tuples of all winning positions for w in all_winning: if w[0] in person_choices and w[1] in person_choices and w[2] in person_choices: return 10, &quot;Player wins&quot;, True for w in all_winning: if w[0] in computer_choices and w[1] in computer_choices and w[2] in computer_choices: return -10, &quot;Computer wins&quot;, True if len(person_choices) + len(computer_choices) == 9: return 0, &quot;Tie&quot;, True return 0, &quot;&quot;, False main(person_choices, computer_choices, gameboard) . Importing Modules . Importing modules and packages Python has two main ways of importing packages or modules Method 1: . import module_or_package . Method 2: . from module_or_package import function_or_class_name . If you use Method 1, you&#39;ll need to reference the module/package followed by a dot and function/class name . import time time.sleep(.5) #sleep for half a second . If you use Method 2, you don&#39;t need to reference the module/package, but run a higher risk of namespace collisions . from time import sleep sleep(.5) . If you had your own function named &#39;sleep&#39;, you would overwrite the sleep function imported from time Notes: . When Python imports a module/package, it essentially pastes its code. It is a recommendeded good practice to place your import statements at the top of your program. | . . Python Data Types . The following link has a great summary Python Data Types. There is an important distinction between mutable and immutable data type . Lists, dictionaries, and sets are mutable, meaning that their elements can be reassigned to different values after creation | Tuples, strings, Numbers, etc. are immutable For example, inside the gameboard list, there are lists (inside []) and tuples (inside ()). Only the values inside lists can be changed. If we try to change (mutate) a value inside one of the tuples, we will get an error. . gameboard = [[&#39;1&#39;, &#39;|&#39;, &#39;2&#39;, &#39;|&#39;, &#39;3&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;4&#39;, &#39;|&#39;, &#39;5&#39;, &#39;|&#39;, &#39;6&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;7&#39;, &#39;|&#39;, &#39;8&#39;, &#39;|&#39;, &#39;9&#39;]] . | Python has truthy and falsy values. 0, False, None, &quot;&quot;, [], (), {}, set(), etc. are falsy, all other values are truthy. | We will cover some key aspects of Python data structures below. | . . Lists . Lists in Python Lists in Python are mutable, iterable, and indexable. These are somewhat similar to ArrayLists in Java and very similar to arrays in Javascript. Unlike ArrayLists in Java, Python lists can contain elements of different data types. In practice, however, lists are usually used to store elements of the same data type. . Here are some basic operations on a list. . &gt; &gt;&gt; l = [0,2,4] &gt;&gt;&gt; l[1]=7 &gt;&gt;&gt; l [0, 7, 4] &gt;&gt;&gt; l.append(10) &gt;&gt;&gt; l [0, 7, 4, 10] &gt;&gt;&gt; l.remove(4) &gt;&gt;&gt; l [0, 7, 10] &gt;&gt;&gt; l.insert(0,100) &gt;&gt;&gt; l [100, 0, 7, 10] &gt;&gt;&gt; l.sort() &gt;&gt;&gt; l [0, 7, 10, 100] &gt;&gt;&gt; last = l.pop() &gt;&gt;&gt; last 100 &gt;&gt;&gt; l [0, 7, 10] &gt;&gt;&gt; l.extend([1,2,3]) &gt;&gt;&gt; l [0, 7, 10, 1, 2, 3] . In the following example, elements of the two-dimensional list board are updated to symbol (symbol = &quot;X&quot; if user == &quot;person&quot; else &quot;O&quot;). The position is then appended to either the list of person or computer choices. . def position_helper(a, b, c, board, position, symbol) -&gt; None:&quot;&quot;&quot;Used in the place_position function to avoid repetition&quot;&quot;&quot; for i in range(a, b): if position == i: board[c][2 * (i - a)] = symbol if symbol == &#39;X&#39;: person_choices.append(position) elif symbol == &#39;O&#39;: computer_choices.append(position) . . Tuples and Tuple Unpacking . Tuples and Tuple Unpacking Unlike lists, tuples are immutable. They also often contain heterogeneous data types, as we will see in the examples of unpacked tuples below. In addition, tuples are more performant than lists: as often there is a trade-off between performance and flexibility (the ability to mutate the list here). Tuples in Python are denoted mainly by commas and the parentheses are optional. They can be unpacked into individual variables. For example, the function _checkwinner returns a tuple containing three elements. We are not interested in assigning a value to the first element, and by convention _ is used for such variables, as in the following examples. . _, winner, game_over = check_winner( person_choices, computer_choices) score, *_ = minimax( board, depth + 1, False, person_choices, computer_choices) . In the second example, two variables were stored in _ since minimax returns a tuple of three elements. We could, of course, also have stored them for future use as follows . score, *list_ = minimax( board, depth + 1, False, person_choices, computer_choices) . Since minimax returns best_score, best_move_row, best_movecol, list[0] would be best_moverow and list[1] best_move_col. _Please feel free to igore the Remark 1 on your first read. Sometimes a function may require a tuple argument. For example, suppose we want to pass an (x,y) coordinate pair to function describe. In this case, we would need to use the parentheses as in the following example. . def describe(coord): print(f&quot;This coordinate&#39;s x value is {coord[0]} and y value is {coord[1]}&quot;) describe((3,4)) &gt; &gt;&gt; This coordinate&#39;s x value is 3 and y value is 4 . The print function will be described below. IMPORTANT:Notice how when * is used to the right of the equal sign, it packs the values into a tuple and when it is inside a function signature (or any place on the left of equal sign), it unpacks them.python . Remark 1: As a sidenote, list is a list. This is a built-in data type in Python, and an underscore can be used so that Python does not confuse it with the list constructor (more on OOP later, but if you&#39;re curious, see the sidenote below). . &gt; &gt;&gt; list=[1,2,3] &gt;&gt;&gt; list [1, 2, 3] &gt;&gt;&gt; print(list) [1, 2, 3] &gt;&gt;&gt; list(&#39;123&#39;) Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;list&#39; object is not callable &gt; &gt;&gt; type(list) &lt;class &#39;list&#39;&gt; &gt;&gt;&gt; list(&#39;Python&#39;) Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;list&#39; object is not callable &gt;&gt;&gt; del list &gt;&gt;&gt; list(&#39;Python&#39;) [&#39;P&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] &gt;&gt;&gt; list(&#39;123&#39;) [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] . . Dictionaries in Python Dictionaries associate keys to values in Python. Here&#39;s the general structure: . dict_ = {key1:val1,key2:val2,...} . Since dict is a data type in Python, I&#39;m using dict_. . The keys must be hashable (immutable and comparable to other keys), which enables rapid retrieval of values. In addition, the retrieval is convenient: if you had to retrieve an element from a list, you would either need to know its index or search for it in O(n) time. If you&#39;re using a dictionary, you can retrieve a value present in dictionary without using an index or searching. This can be done in approximately O(1) time. In the example below, a position number is passed as input and board coordinates are returned. . def convert_pos_to_board(pos) -&gt; tuple: &quot;&quot;&quot;Converts a position 1-9 on the board to board coordinates &quot;&quot;&quot; boardDict = {1: (0, 0), 2: (0, 2), 3: (0, 4), 4: (2, 0), 5: ( 2, 2), 6: (2, 4), 7: (4, 0), 8: (4, 2), 9: (4, 4)} return boardDict[pos] . If an integer not between 1 and 9 were to be passed, we would get a KeyError. Since we made sure that the integer is always between 1 and 9 in the make_move function, this will not happen in our code. In general, though, if we are ever in a sitiation where we do not want our code to crash if a user is trying to pass in a key that&#39;s not in the dictionary, we could use the dictionary&#39;s get method, replacing boardDict[pos] with boardDict.get(pos,0). This method would return the value passed in as the second argument (0 in this case) if a key that&#39;s not in the dictionary is passed. . By dictionaries contain key-value pairs. By default, if we write key in boardDict, Python will loop through the keys. If we want to loop through the values, we would use val in boardDict.values() . boardDict = {1: (0, 0), 2: (0, 2), 3: (0, 4), 4: (2, 0), 5: ( 2, 2), 6: (2, 4), 7: (4, 0), 8: (4, 2), 9: (4, 4)} evens_only = dict() #another way to instantiate a dictionary for key in boardDict: if key%2 == 0: evens_only[key] = boardDict[key] print(evens_only) &gt; &gt;&gt; {2:(0, 2), 4: (2, 0), 6: (2, 4), 8: (4, 2)} . If we want to perform some operation on the values of the dictionary, we can do this using .values() method as in the following example. . vals_add_to_even=[] for val in boardDict.values(): if (val[0]+val[1])%2 == 0: vals_add_to_even.append(val) print(vals_add_to_even) &gt; &gt;&gt; [(0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (2, 4), (4, 0), (4, 2), (4, 4)] . If we want to perform some operation on both keys and values of the dictionary, we can do this using .items() method as in the following example. . evens_only = dict() vals_add_to_even=[] for key,val in boardDict.items():if key%2 == 0: evens_only[key] = boardDict[key] if (val[0]+val[1])%2 == 0: vals_add_to_even.append(val) print(evens_only) print(vals_add_to_even) &gt; &gt;&gt; {2:(0, 2), 4: (2, 0), 6: (2, 4), 8: (4, 2)}&gt; &gt;&gt; [(0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (2, 4), (4, 0), (4, 2), (4, 4)] . Dictionaries in Python 3.7 and above preserve insertion order, they can be sorted, reversed, etc. For more detail, please see https://docs.python.org/3/tutorial/datastructures.html#dictionaries .___ . The _print_ Function and f-strings . The example above includes an f-string. This is Python&#39;s way of doing string interpolation, which means evaluating the string at the specified values (3 for coord[0] and 4 for coord[1] above). Python&#39;s print function is very versatile and can take multiple inputs. . print(1,2,3) &gt;&gt;&gt; 1 2 3 print(&quot;Hello&quot;,&quot;World&quot;) &gt;&gt;&gt; Hello World . The sep keyword parameter can be configured to separate the arguments by something other than &quot; &quot;. . print(1,2,3, sep=&quot;***&quot;) &gt;&gt;&gt; 1***2***3 . The end keyword parameter can be configured to end line with something other than &quot; n&quot; . print(&quot;Hello&quot;) print(&quot;Python&quot;) &gt;&gt;&gt; Hello &gt;&gt;&gt; Python . print(&quot;Hello&quot;,end=&quot;&lt;&gt;&quot;) print(&quot;Python&quot;) . Hello&lt;&gt;Python . . Getting Help in Python . To get help on a built-in function, one would use the help() function . help(print) &gt; &gt;&gt;print(...) print(value, ..., sep=&#39; &#39;, end=&#39; n&#39;, file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments:file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. . This function can also be run at the command line, which is also a good place to do quick experiments ;-) To do this. python help(print) . Help on built-in function print in module builtins:print(...) print(value, ..., sep=&#39; &#39;, end=&#39; n&#39;, file=sys.stdout, flush=False)... . Press q to exit help . Type exit() to exit Python. . . Positional and Keyword Arguments There are more details here, but as a first-order approximation, the positional arguments are mandatory their corresponding parameters appear first in the signature. The keyword arguments are optional. Their corresponding parameters follow the positional parameters and can be identified by the = sign. Let&#39;s examine the signature of the print function, namely . print(value, ..., sep=&#39; &#39;, end=&#39; n&#39;, file=sys.stdout, flush=False) . The function accepts multiple positional arguments as indicated by value,..., which is also commonly denoted by *args. The remaining arguments will be accepted as keyword arguments. Please see the following example. . &gt; &gt;&gt; args=(&#39;hello&#39;,&#39;our&#39;,&#39;world&#39;) &gt;&gt;&gt; print(*args) hello our world &gt;&gt;&gt; kwargs={&#39;end&#39;:&#39;???&#39;,&#39;sep&#39;:&#39;!&#39;}&gt;&gt;&gt; print(*args,**kwargs) hello!our!world???&gt;&gt;&gt; . kwargs is a dictionary, which we&#39;ll cover in more detail later. . . help(print) . Help on built-in function print in module builtins: print(...) print(value, ..., sep=&#39; &#39;, end=&#39; n&#39;, file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. . # signature(describe) # signature(print) . . Exception Handling in Python Let&#39;s examine the following function in detail (I removed the docstring for concision) . def make_move(board, user: str, depth: int, is_max: bool) -&gt; None: while True: try: if user == &quot;person&quot;: position = int(input(&quot;Please enter your placement 1 - 9: &quot;)) while (position in person_choices) or (position in computer_choices): print(&quot;You either did not enter an integer between 1 and 9 or the position is taken&quot;) position = int( input(&quot;Please enter your placement 1 - 9: &quot;)) elif user == &quot;computer&quot;: _, *bestMove = minimax(board, depth, is_max, person_choices, computer_choices) position = convert_to_pos(*bestMove) except ValueError as er: print(&quot;You must enter an integer&quot;, er) else: place_position(position, board, user) break ` . If the user enters an input that cannot be converted to an integer (word &#39;five&#39; instead of number 5, for example), then Python will throw a ValueError. If we do not handle it, our program will crash. In Python, exceptions can be handled with try-except statements. We try to do something, and if it breaks, the code will go through the except statements from top to bottom (hence we should put the most specific ones towards the top, just as with if-elif-else statements). The else statement will run if no except ran. We can also have a finally statement at the end to tie up the loose ends. The finally statement will always run and is useful for many tasks (ex: displaying a final message, closing files, etc.) . Sidenote (can be skipped on first pass): Could we have handled the exceptions with classical if-else logic? Probably yes, but this generally invovles more work. Python&#39;s philosophy is EAFP: “it’s easier to ask for forgiveness than permission” language, not LBYL: “look before you leap” language (such as Java). Python also has a notion of &quot;duck typing&quot;, where we care more about the behavior of an object rather than it&#39;s type. For example, we would find the sum over list or tuple elements in the same way, so we could write a sinle function that would work for both data types (see example below). Contrast this with a statically typed language such as Java, where objects (or primitive types) cannot change types after the initial declaration. . # Example of duck typing def generic_sum(list_or_tuple): total = 0 for elt in list_or_tuple: total += elt return total print(generic_sum((1,2,3))) print(generic_sum([1,2,3])) . def generic_sum(list_or_tuple): total = 0 for elt in list_or_tuple: total += elt return total print(generic_sum((1,2,3))) print(generic_sum([1,2,3])) . 6 6 . . Default Values and Type Annotations in Python Python does not require us to specify the return and parameter types. This allows it to be more flexible, going along with the idea of duck typing. However, as in example above, we can annotate some or all of the types for the parameters and the return value. Python will ignore these annotations, but these can be helpful to another user or a tools used in conjunction with Python (linters, type checkers, IDEs, etc). . . List and Dictionary Comprehensions Python is known for its powerful and flexible list comprehensions. . These are also more readable than map/apply/filter patterns which are available in Python, but would be the main resort in languages such as Javascript. I&#39;m not using list comprehensions in the code above, but I&#39;ll present some examples below. For the questions of removing all instances of a specified number from a list, how would you do it in Java? . #Squaring all elements in a list l_1 = [1,2,3,4,5] l_2 = [elt**2 for elt in l_1] print(l_2) #&gt;&gt;&gt; [1, 4, 9, 16, 25] l_2_evens = [elt**2 for elt in l_1 if elt**2 % 2 == 0] print(l_2_evens) #&gt;&gt;&gt; [4, 16] # A real-life use case: removing elements from a list l = [1,2,3,2,2,2,4,5,6] l.remove(2) print(l) #&gt;&gt;&gt;[1, 3, 2, 2, 2, 4, 5, 6] # only removes the first 2! l = [1,2,3,2,2,2,4,5,6] l_proper = [elt for elt in l if elt != 2] print(l_proper) . Now let&#39;s refactor some of the code given in the Lists section using list and dictionary comprehensions. . boardDict = {1: (0, 0), 2: (0, 2), 3: (0, 4), 4: (2, 0), 5: ( 2, 2), 6: (2, 4), 7: (4, 0), 8: (4, 2), 9: (4, 4)} #BEFORE: 5 lines of code evens_only = dict() #another way to instantiate a dictionary for key in boardDict: if key%2 == 0: evens_only[key] = boardDict[key] print(evens_only) #&gt;&gt;&gt; {2: (0, 2), 4: (2, 0), 6: (2, 4), 8: (4, 2)} #AFTER: 2 lines of code evens_only_compr = {key:boardDict[key] for key in boardDict if key%2 == 0} print(evens_only_compr) #&gt;&gt;&gt; {2: (0, 2), 4: (2, 0), 6: (2, 4), 8: (4, 2)} #BEFORE: 5 lines of code vals_add_to_even=[] for val in boardDict.values(): if (val[0]+val[1])%2 == 0: vals_add_to_even.append(val) print(vals_add_to_even) #&gt;&gt;&gt; [(0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (2, 4), (4, 0), (4, 2), (4, 4)] #AFTER: 2 lines of code vals_add_to_even_compr = [val for val in boardDict.values() if (val[0]+val[1])%2 == 0] print(vals_add_to_even_compr) #&gt;&gt;&gt; [(0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (2, 4), (4, 0), (4, 2), (4, 4)] . PART 2: OOP . Classes and Objects . Python is object-oriented but lacks the access modifiers (eg, private, protected, etc.) present in languages such as Java. We will discuss solutions to this after we cover the basics. An OOP version of the game is below . &quot;&quot;&quot;This program lets a person place the first piece on a Tic-Tac-Toe board. The computer uses the minimax algorithm to ensure that the person never wins (a tie is possible). The game is played in the console and numbers for available position are displayed for the person playing. This feature requires the use of two auxiliary functions. In addition, the best possible score and the best move are calculated in a single run of the minimax algorithm.&quot;&quot;&quot; import time # will use this to introduce a pause between the person&#39;s and computer&#39;s choice class TicTacToeGame: def __init__(self): self.person_choices = [] self.computer_choices = [] self.gameboard = [[&#39;1&#39;, &#39;|&#39;, &#39;2&#39;, &#39;|&#39;, &#39;3&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;4&#39;, &#39;|&#39;, &#39;5&#39;, &#39;|&#39;, &#39;6&#39;], (&#39;-&#39;, &#39;+&#39;, &#39;-&#39;, &#39;+&#39;, &#39;-&#39;), [&#39;7&#39;, &#39;|&#39;, &#39;8&#39;, &#39;|&#39;, &#39;9&#39;]] def run_game(self) -&gt; None: user = &quot;person&quot; game_over = False depth = 0 # no moves yet, will track how many moves forward that the computer will evaluate the board print(&quot;Game board: &quot;) self.print_gameboard() while not game_over: # Score starts with 0, so not score is true, once 10 or -10, not score will be false if user == &quot;person&quot;: is_max = True self.make_move(&quot;person&quot;, depth, is_max) self.print_gameboard() _, winner, game_over = self.check_winner() if winner != &quot;Tie&quot; and winner != &quot;&quot;: print(winner) elif game_over: print(&quot;Tie&quot;) time.sleep(.5) user = &quot;computer&quot; elif user == &quot;computer&quot;: is_max = False self.make_move(&quot;computer&quot;, depth, is_max) print(&quot;Computer&#39;s move: &quot;) self.print_gameboard() _, winner, game_over = self.check_winner() if winner != &quot;Tie&quot; and winner != &quot;&quot;: print(winner) elif game_over: print(&quot;Tie&quot;) user = &quot;person&quot; def print_gameboard(self) -&gt; None: &quot;&quot;&quot;Prints the board&quot;&quot;&quot; for i in range(0, len(self.gameboard)): for j in range(0, len(self.gameboard)): print(self.gameboard[i][j], end=&quot; &quot;) print() def make_move(self, user: str, depth: int, is_max: bool) -&gt; None: &quot;&quot;&quot;make_move function takes in the board, the user, depth, and is_max. is_max is True if it&#39;s the person&#39;s term, False otherwise. This function requires input from the user and definitively places the piece, hence it&#39;s not used in minimax&quot;&quot;&quot; while True: try: if user == &quot;person&quot;: position = int( input(&quot;Please enter your placement 1 - 9: &quot;)) while (position in self.person_choices) or (position in self.computer_choices): print( &quot;You either did not enter an integer between 1 and 9 or the position is taken&quot;) position = int( input(&quot;Please enter your placement 1 - 9: &quot;)) elif user == &quot;computer&quot;: _, *bestMove = self.minimax(depth, is_max) position = self.convert_to_pos(*bestMove) except ValueError as er: print(&quot;You must enter an integer&quot;, er) else: self.place_position(position, user) break def place_position(self, position, user) -&gt; None: &quot;&quot;&quot;Places the user&#39;s piece at the specified position on the board&quot;&quot;&quot; symbol = &quot;X&quot; if user == &quot;person&quot; else &quot;O&quot; # fills out the first row of of the board self.position_helper(1, 4, 0, position, symbol) # fills out the second row of of the board self.position_helper(4, 7, 2, position, symbol) # fills out the third row of of the board self.position_helper(7, 10, 4, position, symbol) def position_helper(self, a, b, c, position, symbol) -&gt; None: &quot;&quot;&quot;Used in the place_position function to avoid repetition&quot;&quot;&quot; for i in range(a, b): if position == i: self.gameboard[c][2 * (i - a)] = symbol if symbol == &#39;X&#39;: self.person_choices.append(position) elif symbol == &#39;O&#39;: self.computer_choices.append(position) def convert_to_pos(self, i, j) -&gt; int: &quot;&quot;&quot;Converts board coordinates to a position 1-9 on the board&quot;&quot;&quot; positionsDict = {(0, 0): 1, (0, 2): 2, (0, 4): 3, (2, 0): 4, (2, 2): 5, (2, 4): 6, (4, 0): 7, (4, 2): 8, (4, 4): 9} return positionsDict[(i, j)] def convert_pos_to_board(self, pos) -&gt; tuple: &quot;&quot;&quot;Converts a position 1-9 on the board to board coordinates &quot;&quot;&quot; boardDict = {1: (0, 0), 2: (0, 2), 3: (0, 4), 4: (2, 0), 5: ( 2, 2), 6: (2, 4), 7: (4, 0), 8: (4, 2), 9: (4, 4)} return boardDict[pos] def minimax(self, depth, is_max) -&gt; &quot;tuple (&#39;best_score&#39;, &#39;best_move_row&#39;, &#39;best_move_col&#39;)&quot;: &quot;&quot;&quot;The minimax algorithm evaluates all future positions, assuming that the opponent plays optimally in the future. It returns the score, row, and column of the best move&quot;&quot;&quot; user = &quot;person&quot; if is_max else &quot;computer&quot; score, *_ = self.check_winner() if score == 10 or score == -10: return score, 1, 1 # come back to this and see if can fix if len(self.person_choices) + len(self.computer_choices) == 9: return 5, 0, 0 if is_max: # person&#39;s turn best_score, best_move_row, best_move_col = -1000, 1, 1 for i in range(3): for j in range(3): if self.gameboard[2 * i][2 * j] != &quot;X&quot; and self.gameboard[2 * i][2 * j] != &quot;O&quot;: position = self.convert_to_pos(2 * i, 2 * j) self.place_position(position, user) score, *_ = self.minimax(depth + 1, False) # The call above will build up a recursive stack and &#39;write&#39; on the board + append # to person_choices and/or self.computer_choices. Will need to undo these side-effects below # since all we want minimax to return is the best next move # Because place_position will call position_helper, which will append to person_choices self.person_choices.pop() m, n = self.convert_pos_to_board(position) # undoing the move and rewriting the num on board self.gameboard[m][n] = position if score &gt; best_score: best_score, best_move_row, best_move_col = score, m, n else: # repetitive logic, but easier to see the algorithm at a glance this way best_score, best_move_row, best_move_col = 1000, -1, -1 for i in range(3): for j in range(3): if self.gameboard[2 * i][2 * j] != &quot;X&quot; and self.gameboard[2 * i][2 * j] != &quot;O&quot;: position = self.convert_to_pos(2 * i, 2 * j) self.place_position(position, user) score, *_ = self.minimax(depth + 1, True) self.computer_choices.pop() m, n = self.convert_pos_to_board(position) self.gameboard[m][n] = position if score &lt; best_score: best_score, best_move_row, best_move_col = score, m, n return best_score, best_move_row, best_move_col def check_winner(self) -&gt; &quot;tuple (&#39;score&#39;, &#39;result&#39;, &#39;game_over&#39;)&quot;: &quot;&quot;&quot;Given user, person_choices, and computer_choices, checks for the winner. Return the score, winner/tie/&quot;&quot;, and True if the game is over/False if not&quot;&quot;&quot; all_winning = ((1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 4, 7), (2, 5, 8), (3, 6, 9), (1, 5, 9), (3, 5, 7)) # tuple of tuples of all winning positions for w in all_winning: if w[0] in self.person_choices and w[1] in self.person_choices and w[2] in self.person_choices: return 10, &quot;Player wins&quot;, True for w in all_winning: if w[0] in self.computer_choices and w[1] in self.computer_choices and w[2] in self.computer_choices: return -10, &quot;Computer wins&quot;, True if len(self.person_choices) + len(self.computer_choices) == 9: return 0, &quot;Tie&quot;, True return 0, &quot;&quot;, False game = TicTacToeGame() game.run_game() .",
            "url": "https://dapopov-st.github.io/LearnPythonThroughTIcTacToe/ai/python/2022/04/20/Guide-To-Python-Through-Tic-Tac-Toe-v2.html",
            "relUrl": "/ai/python/2022/04/20/Guide-To-Python-Through-Tic-Tac-Toe-v2.html",
            "date": " • Apr 20, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://dapopov-st.github.io/LearnPythonThroughTIcTacToe/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://dapopov-st.github.io/LearnPythonThroughTIcTacToe/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website aims to introduce students of other languages to Python .",
          "url": "https://dapopov-st.github.io/LearnPythonThroughTIcTacToe/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://dapopov-st.github.io/LearnPythonThroughTIcTacToe/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}